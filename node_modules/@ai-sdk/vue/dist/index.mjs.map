{"version":3,"sources":["../src/use-completion.ts","../src/chat.vue.ts","../src/use-object.ts"],"sourcesContent":["import type { CompletionRequestOptions, UseCompletionOptions } from 'ai';\nimport { callCompletionApi } from 'ai';\nimport swrv from 'swrv';\nimport type { Ref } from 'vue';\nimport { ref, unref } from 'vue';\n\nexport type { UseCompletionOptions };\n\nexport type UseCompletionHelpers = {\n  /** The current completion result */\n  completion: Ref<string>;\n  /** The error object of the API request */\n  error: Ref<undefined | Error>;\n  /**\n   * Send a new prompt to the API endpoint and update the completion state.\n   */\n  complete: (\n    prompt: string,\n    options?: CompletionRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current API request but keep the generated tokens.\n   */\n  stop: () => void;\n  /**\n   * Update the `completion` state locally.\n   */\n  setCompletion: (completion: string) => void;\n  /** The current value of the input */\n  input: Ref<string>;\n  /**\n   * Form submission handler to automatically reset input and append a user message\n   * @example\n   * ```jsx\n   * <form @submit=\"handleSubmit\">\n   *  <input @change=\"handleInputChange\" v-model=\"input\" />\n   * </form>\n   * ```\n   */\n  handleSubmit: (event?: { preventDefault?: () => void }) => void;\n  /** Whether the API request is in progress */\n  isLoading: Ref<boolean | undefined>;\n};\n\nlet uniqueId = 0;\n\n// @ts-expect-error - some issues with the default export of useSWRV\nconst useSWRV = (swrv.default as (typeof import('swrv'))['default']) || swrv;\nconst store: Record<string, any> = {};\n\nexport function useCompletion({\n  api = '/api/completion',\n  id,\n  initialCompletion = '',\n  initialInput = '',\n  credentials,\n  headers,\n  body,\n  streamProtocol,\n  onFinish,\n  onError,\n  fetch,\n}: UseCompletionOptions = {}): UseCompletionHelpers {\n  // Generate an unique id for the completion if not provided.\n  const completionId = id || `completion-${uniqueId++}`;\n\n  const key = `${api}|${completionId}`;\n  const { data, mutate: originalMutate } = useSWRV<string>(\n    key,\n    () => store[key] || initialCompletion,\n  );\n\n  const { data: isLoading, mutate: mutateLoading } = useSWRV<boolean>(\n    `${completionId}-loading`,\n    null,\n  );\n\n  isLoading.value ??= false;\n\n  // Force the `data` to be `initialCompletion` if it's `undefined`.\n  data.value ||= initialCompletion;\n\n  const mutate = (data: string) => {\n    store[key] = data;\n    return originalMutate();\n  };\n\n  // Because of the `initialData` option, the `data` will never be `undefined`.\n  const completion = data as Ref<string>;\n\n  const error = ref<undefined | Error>(undefined);\n\n  let abortController: AbortController | null = null;\n\n  async function triggerRequest(\n    prompt: string,\n    options?: CompletionRequestOptions,\n  ) {\n    return callCompletionApi({\n      api,\n      prompt,\n      credentials,\n      headers: {\n        ...headers,\n        ...options?.headers,\n      },\n      body: {\n        ...unref(body),\n        ...options?.body,\n      },\n      streamProtocol,\n      setCompletion: mutate,\n      setLoading: loading => mutateLoading(() => loading),\n      setError: err => {\n        error.value = err;\n      },\n      setAbortController: controller => {\n        abortController = controller;\n      },\n      onFinish,\n      onError,\n      fetch,\n    });\n  }\n\n  const complete: UseCompletionHelpers['complete'] = async (\n    prompt,\n    options,\n  ) => {\n    return triggerRequest(prompt, options);\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setCompletion = (completion: string) => {\n    mutate(completion);\n  };\n\n  const input = ref(initialInput);\n\n  const handleSubmit = (event?: { preventDefault?: () => void }) => {\n    event?.preventDefault?.();\n    const inputValue = input.value;\n    return inputValue ? complete(inputValue) : undefined;\n  };\n\n  return {\n    completion,\n    complete,\n    error,\n    stop,\n    setCompletion,\n    input,\n    handleSubmit,\n    isLoading,\n  };\n}\n","import {\n  AbstractChat,\n  ChatInit as BaseChatInit,\n  ChatState,\n  ChatStatus,\n  UIMessage,\n} from 'ai';\nimport { Ref, ref } from 'vue';\n\nclass VueChatState<UI_MESSAGE extends UIMessage>\n  implements ChatState<UI_MESSAGE>\n{\n  private messagesRef: Ref<UI_MESSAGE[]>;\n  private statusRef = ref<ChatStatus>('ready');\n  private errorRef = ref<Error | undefined>(undefined);\n\n  constructor(messages?: UI_MESSAGE[]) {\n    this.messagesRef = ref(messages ?? []) as Ref<UI_MESSAGE[]>;\n  }\n\n  get messages(): UI_MESSAGE[] {\n    return this.messagesRef.value;\n  }\n\n  set messages(messages: UI_MESSAGE[]) {\n    this.messagesRef.value = messages;\n  }\n\n  get status(): ChatStatus {\n    return this.statusRef.value;\n  }\n\n  set status(status: ChatStatus) {\n    this.statusRef.value = status;\n  }\n\n  get error(): Error | undefined {\n    return this.errorRef.value;\n  }\n\n  set error(error: Error | undefined) {\n    this.errorRef.value = error;\n  }\n\n  pushMessage = (message: UI_MESSAGE) => {\n    this.messagesRef.value = [...this.messagesRef.value, message];\n  };\n\n  popMessage = () => {\n    this.messagesRef.value = this.messagesRef.value.slice(0, -1);\n  };\n\n  replaceMessage = (index: number, message: UI_MESSAGE) => {\n    // message is cloned here because vue's deep reactivity shows unexpected behavior, particularly when updating tool invocation parts\n    this.messagesRef.value[index] = { ...message };\n  };\n\n  snapshot = <T>(value: T): T => value;\n}\n\nexport class Chat<\n  UI_MESSAGE extends UIMessage,\n> extends AbstractChat<UI_MESSAGE> {\n  constructor({ messages, ...init }: BaseChatInit<UI_MESSAGE>) {\n    super({\n      ...init,\n      state: new VueChatState(messages),\n    });\n  }\n}\n","import { ref, type Ref } from 'vue';\nimport swrv from 'swrv';\nimport {\n  isAbortError,\n  safeValidateTypes,\n  type FetchFunction,\n  type InferSchema,\n} from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  type DeepPartial,\n  isDeepEqualData,\n  parsePartialJson,\n  type Schema,\n} from 'ai';\nimport * as z3 from 'zod/v3';\nimport * as z4 from 'zod/v4';\n\n// use function to allow for mocking in tests\nconst getOriginalFetch = () => fetch;\n\nexport type Experimental_UseObjectOptions<\n  SCHEMA extends z4.core.$ZodType | z3.Schema | Schema,\n  RESULT,\n> = {\n  /** API endpoint that streams JSON chunks matching the schema */\n  api: string;\n\n  /** Zod or AI schema that defines the final object shape */\n  schema: SCHEMA;\n\n  /** Shared state key. If omitted a random one is generated */\n  id?: string;\n\n  /** Initial partial value */\n  initialValue?: DeepPartial<RESULT>;\n\n  /** Optional custom fetch implementation */\n  fetch?: FetchFunction;\n\n  /** Called when stream ends */\n  onFinish?: (event: {\n    object: RESULT | undefined;\n    error: Error | undefined;\n  }) => Promise<void> | void;\n\n  /** Called on error */\n  onError?: (error: Error) => void;\n\n  /** Extra request headers */\n  headers?: Record<string, string> | Headers;\n\n  /** Request credentials mode. Defaults to 'same-origin' if omitted */\n  credentials?: RequestCredentials;\n};\n\nexport type Experimental_UseObjectHelpers<RESULT, INPUT> = {\n  /** POST the input and start streaming */\n  submit: (input: INPUT) => void;\n\n  /** Current partial object, updated as chunks arrive */\n  object: Ref<DeepPartial<RESULT> | undefined>;\n\n  /** Latest error if any */\n  error: Ref<Error | undefined>;\n\n  /** Loading flag for the in-flight request */\n  isLoading: Ref<boolean | undefined>;\n\n  /** Abort the current request. Keeps current partial object. */\n  stop: () => void;\n\n  /** Abort and clear all state */\n  clear: () => void;\n};\n\nlet uniqueId = 0;\n\n// @ts-expect-error - some issues with the default export of useSWRV\nconst useSWRV = (swrv.default as (typeof import('swrv'))['default']) || swrv;\nconst store: Record<string, any> = {};\n\nexport const experimental_useObject = function useObject<\n  SCHEMA extends z4.core.$ZodType | z3.Schema | Schema,\n  RESULT = InferSchema<SCHEMA>,\n  INPUT = any,\n>({\n  api,\n  id,\n  schema,\n  initialValue,\n  fetch,\n  onError,\n  onFinish,\n  headers,\n  credentials,\n}: Experimental_UseObjectOptions<\n  SCHEMA,\n  RESULT\n>): Experimental_UseObjectHelpers<RESULT, INPUT> {\n  // Generate an unique id for the object if not provided.\n  const completionId = id || `completion-${uniqueId++}`;\n\n  const key = `${api}|${completionId}`;\n  const { data, mutate: originalMutate } = useSWRV<\n    DeepPartial<RESULT> | undefined\n  >(key, () => (key in store ? store[key] : initialValue));\n\n  const { data: isLoading, mutate: mutateLoading } = useSWRV<boolean>(\n    `${completionId}-loading`,\n    null,\n  );\n\n  isLoading.value ??= false;\n  data.value ||= initialValue as DeepPartial<RESULT> | undefined;\n\n  const mutateObject = (value: DeepPartial<RESULT> | undefined) => {\n    store[key] = value;\n    return originalMutate();\n  };\n\n  const error = ref<Error | undefined>(undefined);\n  let abortController: AbortController | null = null;\n\n  const stop = async () => {\n    if (abortController) {\n      try {\n        abortController.abort();\n      } catch {\n        // ignore\n      } finally {\n        abortController = null;\n      }\n    }\n    await mutateLoading(() => false);\n  };\n\n  const clearObject = async () => {\n    error.value = undefined;\n    await mutateLoading(() => false);\n    await mutateObject(undefined);\n    // Need to explicitly set the value to undefined to trigger a re-render\n    data.value = undefined;\n  };\n\n  const clear = async () => {\n    await stop();\n    await clearObject();\n  };\n\n  const submit = async (input: INPUT) => {\n    try {\n      await clearObject();\n      await mutateLoading(() => true);\n\n      abortController = new AbortController();\n\n      const actualFetch = fetch ?? getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(headers as any),\n        },\n        credentials: credentials ?? 'same-origin',\n        signal: abortController.signal,\n        body: JSON.stringify(input),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          (await response.text()) || 'Failed to fetch the response.',\n        );\n      }\n\n      if (!response.body) {\n        throw new Error('The response body is empty.');\n      }\n\n      let accumulatedText = '';\n      let latestObject: DeepPartial<RESULT> | undefined = undefined;\n\n      await response.body.pipeThrough(new TextDecoderStream()).pipeTo(\n        new WritableStream<string>({\n          async write(chunk) {\n            accumulatedText += chunk;\n            const { value } = await parsePartialJson(accumulatedText);\n            const currentObject = value as DeepPartial<RESULT>;\n            if (!isDeepEqualData(latestObject, currentObject)) {\n              latestObject = currentObject;\n              await mutateObject(currentObject);\n            }\n          },\n          async close() {\n            await mutateLoading(() => false);\n            abortController = null;\n\n            if (onFinish) {\n              const validationResult = await safeValidateTypes({\n                value: latestObject,\n                schema: asSchema(schema),\n              });\n\n              onFinish(\n                validationResult.success\n                  ? {\n                      object: validationResult.value as RESULT,\n                      error: undefined,\n                    }\n                  : { object: undefined, error: validationResult.error },\n              );\n            }\n          },\n        }),\n      );\n    } catch (err: unknown) {\n      if (isAbortError(err)) return;\n\n      if (onError && err instanceof Error) onError(err);\n\n      await mutateLoading(() => false);\n      error.value = err instanceof Error ? err : new Error(String(err));\n    }\n  };\n\n  return {\n    submit,\n    object: data,\n    error,\n    isLoading,\n    stop,\n    clear,\n  };\n};\n"],"mappings":"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","names":["fetch","data","completion","_a","ref","ref","swrv","uniqueId","useSWRV","store","fetch"]}